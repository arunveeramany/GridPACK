\chapter{Optimization}

GridPACK supports optimization via an interface that can be applied to bus and banch components, as well as wrappers to some common optimization libraries. At present, there are no example problems available for the optimization capability in GridPACK.
The optimization interface can be optionally inherited by the bus and branch classes. Unlike the other interfaces described in this document, this is not already included in the \texttt{\textbf{BaseBusComponent}} and \texttt{\textbf{BaseBranchComponent}} classes. A component that wants to use the optimization interface must explicitly inherit the interface when declaring the class. The optimization interface is built up around the \texttt{\textbf{Expression}} class that is designed to provide some functional programming capability to GridPACK. This functionality matches the interfaces to many optimization packages. Additional classes needed by the optimization interface are the \texttt{\textbf{Variable}} class and the \texttt{\textbf{Constraint}} class.

The \texttt{\textbf{Variable}}, \texttt{\textbf{Expression}} and \texttt{\textbf{Constraint}} classes are defined in the \texttt{\textbf{gridpack::optimization}} namespace. A number of different types of variables inherit from \texttt{\textbf{Variable}}. This includes \texttt{\textbf{RealVariable}}, \texttt{\textbf{IntegerVariable and BinaryVariable}}. Variables can take on different values and are designed to be used as parts of expressions. Expressions, in turn, can be composed of variables and can also be composed of other expressions. This allows users to build up quite complicated functions. An example of an expression is the following

{
\color{red}
\begin{Verbatim}[fontseries=b]
    typdef boost::shared_ptr<Variable> VarPtr;
    typedef boost::shared_ptr<Expression> ExpPtr;

    VarPtr x;
    ExpPtr f;
    x.reset(new RealVariable(0.0));
    ExpPtr a(new RealConstant(5.0));
    ExpPtr b(new RealConstant(-2.0));
    f = a*x + b;
\end{Verbatim}
}

This code fragment defines the function \texttt{\textbf{f}}. Note that the last line is not an assignment in the conventional sense; \texttt{\textbf{f}} does not represent the value computed from the current values of \texttt{\textbf{a}}, \texttt{\textbf{x}}, and \texttt{\textbf{b}} but rather the operation of multiplying \texttt{\textbf{x}} by the constant value \texttt{\textbf{a}} and then adding the constant value \texttt{\textbf{b}} to the result.

The functions in the optimization interface are all expressed in terms of the \texttt{\textbf{Expression}} and \texttt{\textbf{Variable}} classes. Apart from simple constructors and destructors, there are only three functions in this interface. The first of these returns a list of all variables associated with a particular bus or branch.

{
\color{red}
\begin{Verbatim}[fontseries=b]
std::vector<boost::shared_ptr<Variable> > getVariables()
\end{Verbatim}
}

Note that the variables returned by a network component can be used in expressions generated by other components but all variables in the problem should be returned by one component somewhere in the network and by no more than one component. This function is called by the optimizer to get a complete listing of variables. Ghost buses and branches do not call this function.

The second function is used to determine the constraints in the system. A constraint is a relation between two expressions. Allowed relations are \texttt{\textbf{$\boldsymbol{\mathrm{<}}$=}}, \texttt{\textbf{$\boldsymbol{\mathrm{>}}$=}} and \texttt{\textbf{==}}. The function

{
\color{red}
\begin{Verbatim}[fontseries=b]
std::vector<boost::shared_ptr<Constraint> > getLocalConstraints()
\end{Verbatim}
}

returns a list of constraints that are associated with a particular network component. This function assumes that all returned constraints can be evaluated by the associated network component. Constraints that are functions of variables on the component plus variables on attached components fall into this category. Simple constraints defined as being numerical bounds on the value of a variable can be incorporated into the variables definitions. The \texttt{\textbf{Constraint}} class is designed to handle more complicated constraints that are functions of one or more variables.

The final function in the optimization interface is

{
\color{red}
\begin{Verbatim}[fontseries=b]
boost::share_ptr<Expression> getObjectiveFunction()
\end{Verbatim}
}

This function assumes that the objective function for the entire system is a sum of terms contributed by each network component. Buses are branches that contribute nothing can return a null pointer. These three functions can be used to define the complete optimization problem. The remainder of this section will expand on the different classes used to implement these functions.
The \texttt{\textbf{Variable}} class is used to define different types of variables. Variables can have real values, integer values or they can be binary swiches (0 and 1). All types of variables are derived from the \texttt{\textbf{Variable}} base class. The \texttt{\textbf{RealVariable}} class has two constructors

{
\color{red}
\begin{Verbatim}[fontseries=b]
RealVariable(double val)

RealVariable(double val, double vmin, double vmax)
\end{Verbatim}
}

The first constructor initializes the variable with the value \texttt{\textbf{val}}, the second constructor initializes the variable with the value \texttt{\textbf{val}} and applies the constraints

{
\color{red}
\begin{Verbatim}[fontseries=b]
    val >= vmin
    val <= vmax
\end{Verbatim}
}

to the variable. These constraints could also be applied using the \texttt{\textbf{Constraint}} class, but this is obviously simpler, if applicable. The variable can be named using the method

{
\color{red}
\begin{Verbatim}[fontseries=b]
void name(const std::string name)
\end{Verbatim}
}

The name of the variable can be recovered by the user with the function

{
\color{red}
\begin{Verbatim}[fontseries=b]
std::string name() const
\end{Verbatim}
}

The name is an important property of the variable. It allows the application to identify two variables as representing the same quantity if they are located on different network components. This can happen with ghost buses and branches, where multiple copies of the same bus or branch may exist in the system. To make sure that the application can identify variables from different copies of the same network components as being the same, the variables defined within the copies must all have the same names. Conversely, variables from physically distinct network components need to have unique names that distinguish them from each other.

All variables have an implicit upper and lower bound, even if this is not explicitly set using the constructor. If only the initial value of the variable is set by the constructor, then the upper and low bounds are set internally to machine limited values. The actual limits of the variable, along with the initial value, can be recovered with the functions

{
\color{red}
\begin{Verbatim}[fontseries=b]
double initial() const

double lowerBound() const

double upperBound() const
\end{Verbatim}
}

The \texttt{\textbf{IntegerVariable}} class is similar to the \texttt{\textbf{RealVariable}} class, except that only integer values of the variable are allowed. It has the two constructors

{
\color{red}
\begin{Verbatim}[fontseries=b]
IntegerVariable(int val)

IntegerVariable(int val, int vmin, int vmax)
\end{Verbatim}
}

The behavior of this class is similar to that of \texttt{\textbf{RealVariable}}, except all arguments are integers. Similar to the RealVariable class, the Integer variable class supports the functions

{
\color{red}
\begin{Verbatim}[fontseries=b]
void name(const std::string name)

std::string name() const

int initial() const

int lowerBound() const

int upperBound() const
\end{Verbatim}
}

Finally, the \texttt{\textbf{BinaryVariable}} class has the single constructor

{
\color{red}
\begin{Verbatim}[fontseries=b]
BinaryVariable(int val)
\end{Verbatim}
}

The \texttt{\textbf{BinaryVariable}} class inherits from the \texttt{\textbf{IntegerVariable}} class and has lower and upper bounds of 0 and 1. It can only take on these two values. Similer to the real and integer variable classes, it has the methods

{
\color{red}
\begin{Verbatim}[fontseries=b]
void name(const std::string name)

std::string name() const

int initial() const

int lowerBound() const

int upperBound() const
\end{Verbatim}
}

In this case the last two methods are redundant, since the return values will always be 0 and 1, respectively.

Variables can be used to create expressions. Expressions can consist of a single variable, a constant, or variables and expressions combined together using unary or binary functions. The expression class is designed to support the relatively simple sums over polynomials that are encountered in power grid applications, but even with this limited scope, quite a few complicated functions can be created with it. Expressions never use variables directly, they are composed using variable pointers, so all variables in an expression should be instantiated using a \texttt{\textbf{boost::share\_ptr$\boldsymbol{\mathrm{<}}$Variable$\boldsymbol{\mathrm{>}}$}} construct. Expressions themselves should also be instantiated using a \texttt{\textbf{boost::share\_ptr$\boldsymbol{\mathrm{<}}$Expression$\boldsymbol{\mathrm{>}}$}} construct. To create a simple quadratic polynomial requires the code

{
\color{red}
\begin{Verbatim}[fontseries=b]
VarPtr x;
ExpPtr a(new RealConstant(1.0));
ExpPtr b(new RealConstant(-2.0));
ExpPtr c(new RealConstant(3.0));
x.reset(new RealVariable(0.0,-10.0,10.0));
ExpPtr x2 = x^2;
ExpPtr p = a+b*x+c*x2;
\end{Verbatim}
}

The exponentiation operation in the \texttt{\textbf{Expression}} class does not have the correct precedence behavior so it is necessary to define the \texttt{\textbf{Expression}} \texttt{\textbf{x2}} and then using it to define \texttt{\textbf{p}}. Expressions can be combined using the binary operations

{
\color{red}
\begin{Verbatim}[fontseries=b]
    ExpPtr+ExpPtr
    ExpPtr-ExpPtr
    ExpPtr*ExpPtr
    ExpPtr/ExpPtr
\end{Verbatim}
}

Expressions can also be used in the functions

{
\color{red}
\begin{Verbatim}[fontseries=b]
    ExpPtr^int
    sin(ExpPtr)
    cos(ExpPtr)
\end{Verbatim}
}

More complicated expressions can be built up from these simple operations. A constant expression can be created using the constructs

{
\color{red}
\begin{Verbatim}[fontseries=b]
ExpPtr var(new RealConstant(double));

ExpPtr var(new IntegerConstant(int));
\end{Verbatim}
}

These can then be used in other expressions as parameters.

Finally, constraints can be created using constructs such as

{
\color{red}
\begin{Verbatim}[fontseries=b]
boost::shared_ptr<Constraint> const(ExpPtr1 relation constant);
\end{Verbatim}
}

where the character string relation can be

{
\color{red}
\begin{Verbatim}[fontseries=b]
    ">="
    "<="
    "=="
\end{Verbatim}
}

and constant is a \texttt{\textbf{double}} or \texttt{\textbf{int}} value.
